
// Copyright (c) 2015-2023 niXman (i dot nixman dog gmail dot com). All
// rights reserved.
//
// This file is part of CSPROT(https://github.com/niXman/csprot) project.
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//
//
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef _csprot_hpp_
#define _csprot_hpp_

#include <cstdint>

#if __cplusplus < 201402L
#   error C++14 or greater is required
#endif

namespace csprot {

/**************************************************************************/

namespace {

constexpr std::uint32_t fnv1a(const char *s, std::uint32_t h = 0x811c9dc5) {
    return (*s == 0) ? h : fnv1a(s+1, ((h ^ (*s)) * 0x01000193));
}

} // anon ns

/**************************************************************************/

namespace {

// holder
template<bool, typename CharType, std::uint32_t XorVal, CharType FirstChar, CharType... SecondChars>
struct string_holder;

// spec for plain strings
template<typename CharType, std::uint32_t XorVal, CharType FirstChar, CharType... SecondChars>
struct string_holder<true, CharType, XorVal, FirstChar, SecondChars...> {
protected:
    static constexpr CharType _data[] = { FirstChar, SecondChars..., '\0' };
    constexpr const CharType* c_str() const { return _data; }
};
template <typename CharType, std::uint32_t XorVal, CharType FirstChar, CharType... SecondChars>
constexpr const CharType string_holder<true, CharType, XorVal, FirstChar, SecondChars...>::_data[];

// spec for xor`ed strings
template<typename CharType, std::uint32_t XorVal, CharType FirstChar, CharType... SecondChars>
struct string_holder<false, CharType, XorVal, FirstChar, SecondChars...> {
    static constexpr CharType _data[] = { FirstChar^(char)(XorVal), SecondChars^(char)(XorVal) ..., '\0' };
    mutable char _plain[sizeof(_data)];

    constexpr const CharType* c_str() const {
        std::size_t i = 0;
        for ( ; i < 1+sizeof...(SecondChars); ++i ) {
            _plain[i] = _data[i]^(char)(XorVal);
        }
        _plain[i]=0;

        return _plain;
    }
};
template <typename CharType, std::uint32_t XorVal, CharType FirstChar, CharType... SecondChars>
constexpr const CharType string_holder<false, CharType, XorVal, FirstChar, SecondChars...>::_data[];

} // anon ns

/**************************************************************************/

template<typename CharType, std::uint32_t XorVal, CharType... Chars>
class cstring;

template<
     typename CharType
    ,std::uint32_t XorVal
    ,CharType FirstChar
    ,CharType... SecondChars
>
struct cstring<CharType, XorVal, FirstChar, SecondChars...>
    :string_holder<XorVal==0, CharType, XorVal, FirstChar, SecondChars...> {
private:
    using holder_type = string_holder<XorVal==0, CharType, XorVal, FirstChar, SecondChars...>;

public:
    constexpr cstring() = default;

    constexpr std::size_t     size()     const { return 1+sizeof...(SecondChars); }
    constexpr std::size_t     length()   const { return size(); }
    constexpr bool            empty()    const { return false; }
    constexpr bool            is_plain() const { return XorVal == 0; }
    constexpr bool            is_xored() const { return !is_plain(); }
    constexpr const CharType* data()     const { return holder_type::_data; }
    using holder_type::c_str;

    template<
         std::uint32_t XorVal2
        ,CharType... Chars
    >
    constexpr int compare(const cstring<CharType, XorVal2, Chars...>& other) const {
        for ( std::size_t i = 0; i < size() && i < other.size(); ++i ) {
            if (data()[i] < other.data()[i]) return -1;
            if (data()[i] > other.data()[i]) return 1;
        }

        if (size() < other.size()) return -1;
        if (size() > other.size()) return 1;

        return 0;
    }
};

// spec for empty strings
template<typename CharType, std::uint32_t XorVal>
struct cstring<CharType, XorVal> {
private:
    static constexpr CharType _data = '\0';

public:
    constexpr cstring() = default;

    constexpr std::size_t     size()     const { return 0; }
    constexpr std::size_t     length()   const { return 0; }
    constexpr bool            empty()    const { return true; }
    constexpr bool            is_plain() const { return XorVal == 0; }
    constexpr bool            is_xored() const { return !is_plain(); }
    constexpr const CharType* data()     const { return &_data; }
    constexpr const CharType* c_str()    const { return &_data; }

    template <CharType... OtherChars>
    constexpr int compare(const cstring<CharType, XorVal, OtherChars...>& other) const {
        return other.empty() ? 0 : -1;
    }
};
template<typename CharType, std::uint32_t XorVal>
constexpr const CharType cstring<CharType, XorVal>::_data;

/*****************************************************************************/

// for plain strings
template<typename CharType, CharType... Chars>
constexpr auto operator"" _S() {
    return cstring<CharType, 0, Chars...>();
}

// for xor`ed strings
template<typename CharType, CharType... Chars>
constexpr auto operator"" _XS() {
    return cstring<CharType, fnv1a(__DATE__ __TIME__), Chars...>();
}

#define _CSPROT_CAT2(x, y) x##y
#define _CSPROT_CAT(x, y) _CSPROT_CAT2(x, y)

#define csprot_plain_string(s) _CSPROT_CAT(s, _S)
#define csprot_xored_string(s) _CSPROT_CAT(s, _XS)

/**************************************************************************/

template<
     typename CharType
    ,std::uint32_t XorVal
    ,CharType... LeftChars
    ,CharType... RightChars
>
constexpr auto operator+ (
     const cstring<CharType, XorVal, LeftChars...> &
    ,const cstring<CharType, XorVal, RightChars...> &)
{
    return cstring<CharType, XorVal, LeftChars..., RightChars...>();
}

template<
     typename CharType
    ,std::uint32_t XorValLeft
    ,std::uint32_t XorValRight
    ,CharType... LeftChars
    ,CharType... RightChars
>
constexpr bool operator== (
     const cstring<CharType, XorValLeft, LeftChars...>& lhs
    ,const cstring<CharType, XorValRight, RightChars...>& rhs)
{
    return (lhs.compare(rhs) == 0);
}

template<
     typename CharType
    ,std::uint32_t XorValLeft
    ,std::uint32_t XorValRight
    ,CharType... LeftChars
    ,CharType... RightChars
>
constexpr bool operator!= (
     const cstring<CharType, XorValLeft, LeftChars...>& lhs
    ,const cstring<CharType, XorValRight, RightChars...>& rhs)
{
    return !operator==(lhs, rhs);
}

/**************************************************************************/

} // ns csprot

#endif // _csprot_hpp_
