
// Copyright (c) 2015-2016 niXman (i dot nixman dog gmail dot com). All
// rights reserved.
//
// This file is part of CSPROT(https://github.com/niXman/csprot) project.
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//
//
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef _csprot_hpp_
#define _csprot_hpp_

#include <cstdint>

#if __cplusplus < 201402L
#	error C++14 or greater is required
#endif

namespace csprot {

/**************************************************************************/

namespace {

template<typename>
struct xor_char_type;

template<>
struct xor_char_type<char> {
	static constexpr const char plain_xor = 0;
	static constexpr const char xored_xor = 177;
};

template<>
struct xor_char_type<wchar_t> {
	static constexpr const wchar_t plain_xor = 0;
	static constexpr const wchar_t xored_xor = 157;
};

// holder
template<bool, typename CharType, CharType XorChar, CharType FirstChar, CharType... SecondChars>
struct string_holder;

} // anon ns

/**************************************************************************/

namespace {

// spec for plain strings
template<typename CharType, CharType XorChar, CharType FirstChar, CharType... SecondChars>
struct string_holder<false, CharType, XorChar, FirstChar, SecondChars...> {
protected:
	static constexpr CharType _data[] = { FirstChar^XorChar, SecondChars^XorChar ..., '\0' };

	constexpr const CharType* c_str() const { return _data; }
};
template <typename CharType, CharType XorChar, CharType FirstChar, CharType... SecondChars>
constexpr const CharType string_holder<false, CharType, XorChar, FirstChar, SecondChars...>::_data[];

// spec for xor`ed strings
template<typename CharType, CharType XorChar, CharType FirstChar, CharType... SecondChars>
struct string_holder<true, CharType, XorChar, FirstChar, SecondChars...> {
	static constexpr CharType _data[] = { FirstChar^XorChar, SecondChars^XorChar ..., '\0' };
	mutable char _plain[sizeof(_data)];

	constexpr const CharType* c_str() const {
		std::size_t i = 0;
		for ( ; i < 1+sizeof...(SecondChars); ++i ) {
			_plain[i] = _data[i]^XorChar;
		}
		_plain[i]=0;

		return _plain;
	}
};
template <typename CharType, CharType XorChar, CharType FirstChar, CharType... SecondChars>
constexpr const CharType string_holder<true, CharType, XorChar, FirstChar, SecondChars...>::_data[];

} // anon ns

/**************************************************************************/

template <typename CharType, CharType XorChar, CharType... Chars>
class cstring;

template <typename CharType, CharType XorChar, CharType FirstChar, CharType... SecondChars>
struct cstring<CharType, XorChar, FirstChar, SecondChars...>
	:string_holder<XorChar==xor_char_type<CharType>::xored_xor, CharType, XorChar, FirstChar, SecondChars...> {
private:
	using holder_type = string_holder<XorChar==xor_char_type<CharType>::xored_xor, CharType, XorChar, FirstChar, SecondChars...>;
public:
	constexpr cstring() = default;

	constexpr std::size_t     size()     const { return 1+sizeof...(SecondChars); }
	constexpr std::size_t     length()   const { return size(); }
	constexpr bool            empty()    const { return false; }
	constexpr bool            is_plain() const { return XorChar == xor_char_type<CharType>::plain_xor; }
	constexpr bool            is_xored() const { return XorChar == xor_char_type<CharType>::xored_xor; }
	constexpr const CharType* data()     const { return holder_type::_data; }
	using holder_type::c_str;

	template<
		 CharType XorChar2
		,CharType... Chars
	>
	constexpr int compare(const cstring<CharType, XorChar2, Chars...>& other) const {
		for ( std::size_t i = 0; i < size() && i < other.size(); ++i ) {
			if (data()[i] < other.data()[i]) return -1;
			if (data()[i] > other.data()[i]) return 1;
		}

		if (size() < other.size()) return -1;
		if (size() > other.size()) return 1;

		return 0;
	}
};

// spec for empty strings
template<typename CharType, CharType XorChar>
struct cstring<CharType, XorChar> {
private:
	static constexpr CharType _data = '\0';

public:
	constexpr cstring() = default;

	constexpr std::size_t     size()     const { return 0; }
	constexpr std::size_t     length()   const { return 0; }
	constexpr bool            empty()    const { return true; }
	constexpr bool            is_plain() const { return XorChar == xor_char_type<CharType>::plain_xor; }
	constexpr bool            is_xored() const { return XorChar == xor_char_type<CharType>::xored_xor; }
	constexpr const CharType* data()     const { return &_data; }
	constexpr const CharType* c_str()    const { return &_data; }

	template <CharType... OtherChars>
	constexpr int compare(const cstring<CharType, XorChar, OtherChars...>& other) const {
		return other.empty() ? 0 : -1;
	}
};
template<typename CharType, CharType XorChar>
constexpr const CharType cstring<CharType, XorChar>::_data;

/*****************************************************************************/

// for plain strings
template<typename CharType, CharType... Chars>
constexpr auto operator"" _S() {
	return cstring<CharType, xor_char_type<CharType>::plain_xor, Chars...>();
}

// for xor`ed strings
template<typename CharType, CharType... Chars>
constexpr auto operator"" _XS() {
	return cstring<CharType, xor_char_type<CharType>::xored_xor, Chars...>();
}

/**************************************************************************/

template<
	 typename CharType
	,CharType XorChar
	,CharType... LeftChars
	,CharType... RightChars
>
constexpr auto operator+ (const cstring<CharType, XorChar, LeftChars...> &,
								  const cstring<CharType, XorChar, RightChars...> &)
{
	return cstring<CharType, XorChar, LeftChars..., RightChars...>();
}

template<
	 typename CharType
	,CharType XorCharLeft
	,CharType XorCharRight
	,CharType... LeftChars
	,CharType... RightChars
>
constexpr bool operator== (const cstring<CharType, XorCharLeft, LeftChars...>& lhs,
									const cstring<CharType, XorCharRight, RightChars...>& rhs)
{
	return (lhs.compare(rhs) == 0);
}

template<
	 typename CharType
	,CharType XorCharLeft
	,CharType XorCharRight
	,CharType... LeftChars
	,CharType... RightChars
>
constexpr bool operator!= (const cstring<CharType, XorCharLeft, LeftChars...>& lhs,
									const cstring<CharType, XorCharRight, RightChars...>& rhs)
{
	return !operator==(lhs, rhs);
}

/**************************************************************************/

} // ns csprot

#endif // _csprot_hpp_
